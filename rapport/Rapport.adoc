= Rapport d'analyse des algorithmes pour le projet SAE S2.02 - Exploration algorithmique d'un problème - réalisé par *Kylian GACHET (1A)* et *Illan GABARRA (1A)*
:toc:
:toc-title: Sommaire
//:toc: preamble
:toclevels: 5
:sectnums:
:sectnumlevels: 5

:Entreprise: IUT de Blagnac
:Equipe: 

[cols="4"]
|===
|Version | Date | Binôme | Projet
|1.0 | 16 juin 2023 | G1A : Kylian GACHET, Illan GABARRA | Exploration algorithmique d'un probléme
|=== 

{empty} +

*NOTATION*
|===
|*Cas*|*Sanction*
|Ne compile/s'exécute pas|note finale divisée par 2
|Ne correspond pas à une classe Exercice (cas des main ou des zip)|note finale divisée par 2
|Non respect de la nomenclature précise|-1
|Non respect de l'anonymat|-1
|Non respect de la consigne sur les méhodes de java.util (pour efficacité)|-1
|Passe tous les tests fournis initialement|18
|Passe vos tests supplémentaires plus complets|20
|Fonctionne mais ne passe pas les tests fournis initialement|10
|Ne fonctionne pas (retour eronné, ou pas du bon type attendu)|5
|===
En cas d'ex-aequo, même note. (5/5/3/2 par exemple).

{empty} +



== Introduction

[.text-justify]
La SAE "Exploitation algorithmique d'un problème" comporte deux phases. Dans la première phase, notre objectif est de résoudre un problème qui consiste à classer les mots d'un texte en fonction d'un ordre donné. Pour cela, nous devons respecter certaines contraintes lors de la conception de notre algorithme, notamment en ce qui concerne le choix du langage (Java ou C) et l'utilisation de méthodes spécifiques. De plus, nous devons soumettre deux versions, à savoir la meilleure solution et la pire solution, pour chaque catégorie : simplicité, efficacité et sobriété numérique. +

[.text-justify]
Dans la deuxième phase du concours, nous travaillons en binôme pour comparer et évaluer les différentes solutions. Nous devons évaluer plusieurs solutions en fonction de critères tels que la lisibilité du code, la qualité du code, l'efficacité, la sobriété numérique et le temps d'exécution, mais nous sommes libres de choisir d'autre critére à condition qu'ils soit pertinents. Nous devons justifier nos analyses et classer les solutions en conséquence. +

[.text-justify]
Ce concours d'algorithmes nous permet de mettre en pratique nos compétences en programmation, en résolution de problèmes ainsi qu'en analyse algorithmique. +

== Notation des algorithmes

=== Kylian GACHET (1A)

{empty} +

|=========================================================================================================
| Note  | Algo                | Commentaire 
| 18/20           | 2-simplicite-meilleur.c    | Passe tous les tests fournis initialement      

| 2/20          | 3-simplicitemeilleur.java    | Ne correspond pas à une classe Exercice (cas des main ou des zip) + 
+ Non respect de la nomenclature précise + 
+ Ne fonctionne pas (retour eronné, ou pas du bon type attendu) + 
+ `Suspicion d'utilisation de ChatGPT`

| 5/20          | 23-simplicite-meilleur.java    | Ne correspond pas à une classe Exercice (cas des main ou des zip) + 
+ Fonctionne mais ne passe pas les tests fournis initialement + 
+ `Suspicion d'utilisation de ChatGPT`

| 9/20           | 28-Simplicité-pire.java  | Non respect de la nomenclature précise + 
+ Fonctionne mais ne passe pas les tests fournis initialement + 
+ `Suspicion d'utilisation de ChatGPT`

| 9/20           |  37-simplicite-pire.java | Non respect de la nomenclature précise + 
+ Fonctionne mais ne passe pas les tests fournis initialement   + 
+ `Suspicion d'utilisation de ChatGPT`

| 4.5/20           |  7-efficacite_pire.java  | Ne correspond pas à une classe Exercice (cas des main ou des zip) +
+ Non respect de la nomenclature précise
+ Fonctionne mais ne passe pas les tests fournis initialement   

| 5/20           |  20-efficacite-pire.java  | Ne fonctionne pas (retour eronné, ou pas du bon type attendu)   + 
+ `Suspicion d'utilisation de ChatGPT`  

| 9.5/20           | 22-Efficacite-Meilleur.java | Ne correspond pas à une classe Exercice (cas des main ou des zip) + 
+ Non respect de la nomenclature précise
+ Passe vos tests supplémentaires plus complets 
+ `Suspicion d'utilisation de ChatGPT`       

| 5/20 et Hors concours   | 57-efficacite-meilleur.java    | Ne compile pas + 
+ Fonctionne mais ne passe pas les tests fournis initialement + 
+ `Suspicion d'utilisation de ChatGPT`  

| 2.5/20           | 5-sobriete-pire.java    | Ne correspond pas à une classe Exercice (cas des main ou des zip) + 
+ Ne fonctionne pas (retour eronné, ou pas du bon type attendu) + 
+ `Suspicion d'utilisation de ChatGPT`      

| 9.5/20           |   22-Sobriété-Pire.java     | Ne correspond pas à une classe Exercice (cas des main ou des zip) + 
+ Non respect de la nomenclature précise
+ Passe vos tests supplémentaires plus complets  + 
+ `Suspicion d'utilisation de ChatGPT`  

| 18/20           | 36-sobriete-meilleur.java   | Passe tous les tests fournis initialement + 
+ `Suspicion d'utilisation de ChatGPT`  

| 18/20           | 58-sobriete-meilleure.java   | Passe tous les tests fournis initialement + 
+ `Suspicion d'utilisation de ChatGPT`  

|=========================================================================================================

{empty} +

=== Illan GABARRA (1A)

{empty} +

|=========================================================================================================
| Note  | Algo                | Commentaire 
| 17/20           | 20-efficacite-meilleur.c    | 
Passe tous les tests fournis initialement

Mais pas les tests supplémentaires

Hors concours car utilise la fonction qsort hors dans la catégorie efficacite il ne fallait pas l'utiliser

| 4.5/20          | 56-efficacite-meilleur.java    |
Ne passe pas tous les tests fournis initialement

Ne respecte pas la nomenclature précise

Suspicion de chatGPT

Hors concours car ne compile pas

| 20/20           | 17-efficacite-pire.java  | 

Passe tous les tests même les tests supplémentaires

Suspicion de chatGPT

| 2/20          |  68-EfficacitePire.java |

Ne fonctionne pas

Ne respecte pas la nomenclature précise

Suspicion de chatGPT

Hors concours car ne compile pas

| 2.5/20           |  6-sae2023-2-02-NOM-main.zip  |

Ne correspond pas à une classe Exercice (ZIP du dépot git)

Après rajout de beaucoup d'import : Fonctionne mais ne passe pas les tests fournis initialement

Hors concours car ne compile pas

| 17/20           |  54-simplicite-meilleur.java  |

Passe tous les tests fournis initialement

Mais pas les tests supplémentaires

| 4/20           | 65-Simplicite-Meilleur.java | 

Ne fonctionne pas

Ne respecte pas la nomenclature précise

| 20/20           | 29-simplicite-pire.java    |

Passe tous les tests même les tests supplémentaires

| 9/20           | 36-simplicite-pire.java    |   

Ne passe pas tous les tests fournis initialement

Ne respecte pas la nomenclature précise

| 19/20           |   34-sobriete-meilleur.java     | 

Ne respecte pas la nomenclature précise

Passe tous les tests même les tests supplémentaires

Suspicion de chatGPT

| 2/20           | 57-sobriete-meilleur.java   |

Ne fonctionne pas

Ne respecte pas la nomenclature précise

Suspicion de chatGPT

Hors concours car ne compile pas

| 10/20           | 20-sobriete-pire.java   |

Ne passe pas tous les tests fournis initialement

| 4/20           | 49-PireSobrieteNumerique.java   |

Ne fonctionne pas

Ne respecte pas la nomenclature précise

Suspicion de chatGPT

|=========================================================================================================

{empty} +

== Présentation des outils d'évaluation

[.text-justify]
Pour mener à bien cette évaluation, plusieurs outils ont été utilisés :

[.text-justify]
* *Codacy :* Cet outil open source a été utilisé pour mesurer la qualité du code des différentes solutions. Il fournit des informations sur la maintenabilité, la lisibilité et les bonnes pratiques de codage.

* *Joular :* Cet outil a été utilisé pour évaluer la consommation en ressources des algorithmes, en se concentrant notamment sur la consommation énergétique.

* *Java Profiler :* Cet outil a permis de mesurer le temps d'exécution des différents algorithmes, en fournissant des données précises sur les performances de chaque solution.

* *TempsExecution.java :* Ce programme que nous avons développé nous a été utile pour tester les temps d'éxecutions des algorithmes.

== Présentation des critères de comparaison

[.text-justify]
La notation des algorithmes sera plus sévère si ces derniers ne fonctionnent pas, ne se compilent pas correctement ou échouent aux tests. Dans ce cas, la note finale sera `divisée par deux` avant d'être convertie sur 20. +

[.text-justify]
Pour chaque catégorie, nous allons évaluer la "meilleure" et la "pire" solution. Pour la meilleure solution, nous conserverons la `note la plus élevée`, tandis que pour la pire solution, la `note la plus basse` sera classée en premier.
 
=== Lisibilité du code

[.text-justify]
La lisibilité du code se réfère à sa facilité de compréhension pour les développeurs. Un code bien écrit est clair, bien structuré et utilise des conventions de nommage appropriées. Les bonnes pratiques de lisibilité comprennent l'utilisation de noms de variables significatifs, une indentation cohérente, des commentaires clairs et des espaces blancs judicieux. +
Une code lisible facilite la compréhension, la maintenance et la collaboration entre les membres de l'équipe de développement.

=== Qualité du code

[.text-justify]
Les tests sont des procédures d'évaluation systématiques qui vérifient le bon fonctionnement d'un code. Les tests peuvent être automatisés ou manuels et visent à détecter les erreurs, les bogues et les comportements indésirables. +
Une bonne couverture de test garantit une meilleure fiabilité du code et facilite la maintenance continue en identifiant rapidement les problèmes potentiels. +
La qualité du code peut être évaluée à l'aide d'outils open source tels que `SonarLint` sous VsCode.il effectue des analyses statiques du code pour détecter les erreurs, les problèmes de style et les vulnérabilités de sécurité. +
Ils fournissent des mesures de qualité basées sur des normes et des bonnes pratiques de développement logiciel, permettant aux développeurs d'améliorer la qualité de leur code.

=== Efficacité

[.text-justify]
L'analyse de l'efficacité évalue les performances d'un code en termes de ressources utilisées, telles que le temps et l'espace. Elle implique l'évaluation de la complexité algorithmique, qui mesure comment le temps d'exécution et les ressources augmentent avec la taille de l'entrée. + 
La complexité se réfère à l'analyse de la performance d'un algorithme en fonction de la taille de l'entrée. Elle est souvent exprimée en notation Big O et permet d'estimer la quantité de ressources (temps, espace) nécessaires pour résoudre un problème. +
Une complexité réduite, telle que O(n) ou O(log(n)), indique une meilleure efficacité, tandis qu'une complexité plus élevée, telle que O(n^2) ou O(2^n), peut entraîner des problèmes de performance. +
Une analyse approfondie de l'efficacité permet d'identifier les parties du code qui peuvent être optimisées pour améliorer les performances globales.

=== Sobriété numérique

[.text-justify]
La sobriété numérique concerne la consommation de ressources d'un code, y compris la consommation d'énergie. Un code sobre est optimisé pour utiliser efficacement les ressources disponibles, minimisant ainsi la consommation de ressources telles que le temps de calcul, la mémoire ou l'énergie. L'objectif est d'écrire un code qui accomplisse la tâche souhaitée en utilisant le moins de ressources possible. +
Nous allons utiliser des outils tels que `Joular` peuvent mesurer la consommation en ressources d'un algorithme et aider à identifier les parties du code qui consomment beaucoup de ressources. Cet outil nous permet donc de mesurer la sobriété d’un code.

=== Temps d'exécution

[.text-justify]
Le temps d'exécution fait référence à la durée nécessaire pour exécuter un programme ou une partie spécifique du code. Mesurer le temps d'exécution permet d'identifier les parties du code qui prennent le plus de temps, ce qui peut aider à cibler les optimisations. +
Réduire le temps d'exécution peut améliorer les performances globales du code et offrir une meilleure expérience utilisateur. +
Afin de mesurer le temps d'execution nous allons utiliser le programme `TestTempsExecution.java` codé par nos soins.

=== Maintenabilité

[.text-justify]
La maintenabilité du code concerne sa capacité à être maintenu et modifié efficacement au fil du temps. Un code maintenable est facile à comprendre, à mettre à jour et à améliorer sans introduire de nouveaux bugs. Cela implique la lisibilité du code, la documentation appropriée, l'utilisation de bonnes pratiques de développement et la modularité pour faciliter les modifications. +
Une bonne maintenabilité permet de minimiser les coûts de maintenance et de garantir le bon fonctionnement continu de l'application.

=== Consomation électrique



== Kylian GACHET (1A)

=== Simplicité

==== Meilleur

|=========================================================================================================
| Num Algo | Lisibilité | Qualité | Maintenabilité | Note | Classement Final

| 2 | 9/10 | 8/10 | 7/10 | 24/30 +
=> `*16/20*` | *1*

| 3 |7/10 | 9/10 | 8/10 | 24/30 +
divisé par 2 car ne fonctionne pas => 12/30 +
=> 8/20  | 2

| 23 | 8/10 | 7/10 | 5/10 | 20/30 +
divisé par 2 car ne passe pas les tests => 10/30 +
=> ≈6.6/20  | 3

|=========================================================================================================

`Algorithme Simplicité - Meilleur N°2 :` +

[.text-justify]
* *Lisibilité :* 
** _Justification_ : Les noms de variables sont explicites et bien choisis, par exemple `motsParLettre` pour représenter la map associant chaque lettre à une liste de mots. Cela rend le code facile à comprendre et à suivre.
** _Exemple_ : Les noms de variables tels que `table_ordre`, `liste_t`, `ajouter_mot` sont des exemples de lisibilité du code.

* *Qualité :* 
** _Justification_ : Le programme utilise des structures de données appropriées pour résoudre le problème, telles que les listes chaînées et les tables de correspondance. De plus, les fonctions sont bien définies pour effectuer des opérations spécifiques.
** _Exemple_ : L'utilisation de structures de données comme `cell_t` et `liste_t` ainsi que des fonctions comme `ajouter_cellule` et `rang` démontrent la qualité du code.

* *Maintenabilité :* 
** _Justification_ : Le code est divisé en sections claires avec des commentaires pour expliquer chaque section et chaque fonction. De plus, les noms de variables et de fonctions sont choisis de manière à faciliter la maintenance et les modifications ultérieures.
** _Exemple_ : Les commentaires décrivant les différentes sections du code et l'utilisation de noms significatifs pour les variables et les fonctions contribuent à la maintenabilité du programme.

`Algorithme Simplicité - Meilleur N°3 :` +

[.text-justify]
* *Lisibilité :* 
** _Justification_ : Utilise des commentaires pour expliquer le fonctionnement.
** _Exemple_ : Le commentaire explique clairement que la fonction "solution" trie les mots d'une chaîne de caractères selon un ordre spécifié.

* *Qualité :* 
** _Justification_ : Approche originale qui évite les comparaisons entre les chaînes de caractères.
** _Exemple_ : Utilisation d'une table de correspondance pour déterminer l'ordre des mots, ce qui peut améliorer la qualité en évitant des opérations coûteuses de comparaison.

* *Maintenabilité :* 
** _Justification_ : Utilisation de fonctions distinctes pour rendre le code modulaire.
** _Exemple_ : La fonction "diviserMots" extrait les mots d'une chaîne de caractères, ce qui facilite la maintenance et la réutilisation du code.


`Algorithme Simplicité - Meilleur N°23 :` +

[.text-justify]
* *Lisibilité :* 
** _Justification_ : Noms de variables explicites et bien choisis.
** _Exemple_ : La variable "motsParLettre" représente la map associant chaque lettre à une liste de mots.

* *Qualité :* 
** _Justification_ : Fonctionne mais ne passe pas les tests, cependant bonne gestion des mots.
** _Exemple_ : La méthode "trierMots" divise correctement la phrase en mots, trie les mots par ordre alphabétique et les concatène pour renvoyer la phrase triée.

* *Maintenabilité :* 
** _Justification_ : Manque de modularité et de réutilisabilité.
** _Exemple_ : La logique de tri des mots pourrait être extraite dans une méthode séparée pour faciliter la maintenance et la réutilisation.

==== Pire

|=========================================================================================================
| Num Algo | Lisibilité | Qualité | Maintenabilité | Note | Classement Final

| 28 | 7/10 | 6/10 | 7/10 | 20/30 +
divisé par 2 car ne passe pas les tests => 10/30 +
=> ≈6.6/20 | 2

| 37 | 1/10 | 4/10 | 4/10 | 9/30 +
divisé par 2 car ne passe pas les tests => 4.5/30 +
=> `*≈ 3/20*` | *1*

|=========================================================================================================

`Algorithme Simplicité - Pire N°28 :` +

[.text-justify]
* *Lisibilité :* 
** _Justification_ : Le programme utilise des noms de variables et de fonctions clairs et significatifs. La structure du code est également bien organisée.
** _Exemple_ : Les noms de variables tels que `phrase`, `ordre`, `mots` et `ordreIndex` sont des exemples de lisibilité du code.

* *Qualité :* 
** _Justification_ : Le programme utilise des structures de données appropriées pour résoudre le problème, comme les listes et les maps. De plus, il utilise la méthode `sort` avec un comparateur personnalisé pour trier les mots selon l'ordre spécifié.
** _Exemple_ : L'utilisation de `List<String>`, `Map<Character, Integer>` et `Comparator.comparingInt` pour trier les mots démontre une bonne qualité du code.

* *Maintenabilité :* 
** _Justification_ : Le code est bien structuré. Cependant une extraction de partie de code pour en faire une méthode distinct manque et n'est pas négligable.


`Algorithme Simplicité - Pire N°37 :` +

[.text-justify]
* *Lisibilité :* 
** _Justification_ : Le programme utilise des noms de variables et de fonctions clairs et significatifs. Cependant la structure du code est trés mal organisé.
** _Exemple_ : Les noms de variables tels que `texte`, `ordre` et `mots` sont des exemples de bonne lisibilité du code. Le code n'est pas bien formaté/indenter (tout le code sur une seul ligne)

* *Qualité :* 
** _Justification_ : Le programme utilise des structures de données appropriées pour résoudre le problème, comme les listes et les maps. De plus, la classe `ComparateurOrdreFixe` implémente l'interface `Comparator` pour personnaliser l'ordre de tri.
** _Exemple_ : L'utilisation de `List<String>`, `Map<Character, Integer>` et `Comparator<String>` ainsi que l'implémentation de la méthode `compare` dans `ComparateurOrdreFixe` démontrent la qualité du code.

* *Maintenabilité :* 
** _Justification_ : Le code est bien structuré avec des méthodes et des classes distinctes pour des responsabilités spécifiques. De plus, les commentaires sont absents dans ce programme, ce qui pourrait affecter la maintenabilité à long terme. De plus, la structure du code est trés mal organisé pouvant affecté la prise en charge du code par quelqu'un d'autre.
** _Exemple_ :  La séparation des fonctionnalités dans des méthodes distinctes, comme `solution` et `compare`, contribue à la maintenabilité du programme. Mais le code sur une seul ligne ne contribue pas a la maintenabilité de celui-ci.


=== Efficacité

==== Meilleur

|=========================================================================================================
| Num Algo | Efficacité | Qualité | Temps d'exécution | Note | Classement Final

| 2 |  | |   |  ?/20 | 1

| 2 |  | |   | ?/20 | 1

|=========================================================================================================

==== Pire

|=========================================================================================================
| Num Algo | Efficacité | Qualité | Temps d'exécution | Note | Classement Final

| 2 |  | |   | ?/20 | 1

| 2 |  | |   | ?/20 | 1

|=========================================================================================================

=== Sobriété

==== Meilleur

|=========================================================================================================
| Num Algo | Sobriété Numérique | Qualité | Consommation Electrique | Note | Classement Final

| 2 |  |   |  | ?/20 | 1

| 2 |  |   |  | ?/20 | 1

|=========================================================================================================

==== Pire

|=========================================================================================================
| Num Algo | Sobriété Numérique | Qualité | Consommation Electrique | Note | Classement Final

| 2 |  |   |  | ?/20 | 1

| 2 |  |   |  | ?/20 | 1

|=========================================================================================================

== Illan Gabarra (1A)

=== Simplicité

=== Efficacité

=== Sobriété

Commen utilise les ressources, les stocke et les calcul qu'il fait (s'il passe en revue toutes la liste alors qu'il y pas besoins alors pas bon), complexité 