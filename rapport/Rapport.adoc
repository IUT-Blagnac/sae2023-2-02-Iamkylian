= Rapport d'analyse des algorithmes pour le projet SAE S2.02 - Exploration algorithmique d'un problème - réalisé par *Kylian GACHET (1A)* et *Illan GABARRA (1A)*
:toc:
:toc-title: Sommaire
//:toc: preamble
:toclevels: 5
:sectnums:
:sectnumlevels: 5

:Entreprise: IUT de Blagnac
:Equipe: 

[cols="4"]
|===
|Version | Date | Binôme | Projet
|1.0 | 16 juin 2023 | G1A : Kylian GACHET, Illan GABARRA | Exploration algorithmique d'un probléme
|=== 

{empty} +

== Introduction

[.text-justify]
La SAE "Exploitation algorithmique d'un problème" comporte deux phases. Dans la première phase, notre objectif est de résoudre un problème qui consiste à classer les mots d'un texte en fonction d'un ordre donné. Pour cela, nous devons respecter certaines contraintes lors de la conception de notre algorithme, notamment en ce qui concerne le choix du langage (Java ou C) et l'utilisation de méthodes spécifiques. De plus, nous devons soumettre deux versions, à savoir la meilleure solution et la pire solution, pour chaque catégorie : simplicité, efficacité et sobriété numérique. +

[.text-justify]
Dans la deuxième phase du concours, nous travaillons en binôme pour comparer et évaluer les différentes solutions. Nous devons évaluer plusieurs solutions en fonction de critères tels que la lisibilité du code, la qualité du code, l'efficacité, la sobriété numérique et le temps d'exécution, mais nous sommes libres de choisir d'autre critére à condition qu'ils soit pertinents. Nous devons justifier nos analyses et classer les solutions en conséquence. +

[.text-justify]
Ce concours d'algorithmes nous permet de mettre en pratique nos compétences en programmation, en résolution de problèmes ainsi qu'en analyse algorithmique. +

== Présentation des critères de notation des algorithmes

{empty}

*NOTATION*
|===
|*Cas*|*Sanction*
|Ne compile/s'exécute pas|note finale divisée par 2
|Ne correspond pas à une classe Exercice (cas des main ou des zip)|note finale divisée par 2
|Non respect de la nomenclature précise|-1
|Non respect de l'anonymat|-1
|Non respect de la consigne sur les méhodes de java.util (pour efficacité)|-1
|Passe tous les tests fournis initialement|18
|Passe vos tests supplémentaires plus complets|20
|Fonctionne mais ne passe pas les tests fournis initialement|10
|Ne fonctionne pas (retour eronné, ou pas du bon type attendu)|5
|===
En cas d'ex-aequo, même note. (5/5/3/2 par exemple).

{empty}

== Présentation des critères de comparaison

[.text-justify]
La notation des algorithmes sera plus sévère si ces derniers ne fonctionnent pas, ne se compilent pas correctement ou échouent aux tests. Dans ce cas, la note finale sera `divisée par deux` avant d'être convertie sur 20. +

[.text-justify]
Pour chaque catégorie, nous allons évaluer la "meilleure" et la "pire" solution. Pour la meilleure solution, nous conserverons la `note la plus élevée`, tandis que pour la pire solution, la `note la plus basse` sera classée en premier.
 
=== Lisibilité du code

[.text-justify]
La lisibilité du code se réfère à sa facilité de compréhension pour les développeurs. Un code bien écrit est clair, bien structuré et utilise des conventions de nommage appropriées. Les bonnes pratiques de lisibilité comprennent l'utilisation de noms de variables significatifs, une indentation cohérente, des commentaires clairs et des espaces blancs judicieux. +
Une code lisible facilite la compréhension, la maintenance et la collaboration entre les membres de l'équipe de développement.

=== Qualité du code

[.text-justify]
Les tests sont des procédures d'évaluation systématiques qui vérifient le bon fonctionnement d'un code. Les tests peuvent être automatisés ou manuels et visent à détecter les erreurs, les bogues et les comportements indésirables. +
Une bonne couverture de test garantit une meilleure fiabilité du code et facilite la maintenance continue en identifiant rapidement les problèmes potentiels. +
La qualité du code peut être évaluée à l'aide d'outils open source tels que `SonarLint` sous VsCode.il effectue des analyses statiques du code pour détecter les erreurs, les problèmes de style et les vulnérabilités de sécurité. +
Ils fournissent des mesures de qualité basées sur des normes et des bonnes pratiques de développement logiciel, permettant aux développeurs d'améliorer la qualité de leur code.

=== Efficacité

[.text-justify]
L'analyse de l'efficacité évalue les performances d'un code en termes de ressources utilisées, telles que le temps et l'espace. Elle implique l'évaluation de la complexité algorithmique, qui mesure comment le temps d'exécution et les ressources augmentent avec la taille de l'entrée. + 
La complexité se réfère à l'analyse de la performance d'un algorithme en fonction de la taille de l'entrée. Elle est souvent exprimée en notation Big O et permet d'estimer la quantité de ressources (temps, espace) nécessaires pour résoudre un problème. +
Une complexité réduite, telle que O(n) ou O(log(n)), indique une meilleure efficacité, tandis qu'une complexité plus élevée, telle que O(n^2) ou O(2^n), peut entraîner des problèmes de performance. +
Une analyse approfondie de l'efficacité permet d'identifier les parties du code qui peuvent être optimisées pour améliorer les performances globales.

=== Sobriété numérique

[.text-justify]
La sobriété numérique concerne la consommation de ressources d'un code, y compris la consommation d'énergie. Un code sobre est optimisé pour utiliser efficacement les ressources disponibles, minimisant ainsi la consommation de ressources telles que le temps de calcul, la mémoire ou l'énergie. L'objectif est d'écrire un code qui accomplisse la tâche souhaitée en utilisant le moins de ressources possible. +
Nous allons utiliser des outils tels que `Joular` peuvent mesurer la consommation en ressources d'un algorithme et aider à identifier les parties du code qui consomment beaucoup de ressources. Cet outil nous permet donc de mesurer la sobriété d’un code.

=== Temps d'exécution

[.text-justify]
Le temps d'exécution fait référence à la durée nécessaire pour exécuter un programme ou une partie spécifique du code. Mesurer le temps d'exécution permet d'identifier les parties du code qui prennent le plus de temps, ce qui peut aider à cibler les optimisations. +
Réduire le temps d'exécution peut améliorer les performances globales du code et offrir une meilleure expérience utilisateur. +
Afin de mesurer le temps d'execution nous allons utiliser le programme `TestTempsExecution.java` codé par nos soins.

=== Maintenabilité

[.text-justify]
La maintenabilité du code concerne sa capacité à être maintenu et modifié efficacement au fil du temps. Un code maintenable est facile à comprendre, à mettre à jour et à améliorer sans introduire de nouveaux bugs. Cela implique la lisibilité du code, la documentation appropriée, l'utilisation de bonnes pratiques de développement et la modularité pour faciliter les modifications. +
Une bonne maintenabilité permet de minimiser les coûts de maintenance et de garantir le bon fonctionnement continu de l'application.

=== Consomation électrique


== Présentation des outils d'évaluation

[.text-justify]
Pour mener à bien cette évaluation, plusieurs outils ont été utilisés :

[.text-justify]
* *Codacy :* Cet outil open source a été utilisé pour mesurer la qualité du code des différentes solutions. Il fournit des informations sur la maintenabilité, la lisibilité et les bonnes pratiques de codage.

* *Joular :* Cet outil a été utilisé pour évaluer la consommation en ressources des algorithmes, en se concentrant notamment sur la consommation énergétique.

* *TempsExecution.java :* Ce programme que nous avons développé nous a été utile pour tester les temps d'éxecutions des algorithmes. Cet outil a permis de mesurer le temps d'exécution des différents algorithmes, en fournissant des données précises sur les performances de chaque solution.

* *TestConsoElectrique.java :*

== Prérequis
[.text-justify]
Vérifier la présence du fichier ``.java`` que vous souhaité analyser dans le répertoire ``~/src/analyse/CodeEvaluation``. +
 +

[.text-justify]
Remplacer la ligne n°7 du fichier ``EraserTest.java`` du répertoire ``~/src/test/java`` par le code suivant : +

[SOURCE, java]
----
import analyse.CodeEvaluation.nomfichier.java;
----

[.text-justify]
Et remplacer toutes les notations ``Exercice`` du fichier par ``nomfichierjava``.

[.text-jutify]
Ce programme de test permet de vérifier que le programme traite bien tous les cas donnés. +
 +

[.text-justify]
Le fichier ``TestTempsExecution.java`` du répertoire ``~/src/analyse`` permet d'obtenir les temps d'exécution du programme en fonction de chaînes générées aléatoirement de tailles données.


== Reproductibilité
[.text-justify]
Lancer le code de ``ExerciceTest.java``et vérifier que le programme traite tous les cas donnés.

[.text-justify]
Lancer le code de ``TestTempsExecution.java`` et analyser les temps d'exécution en fonction des différentes tailles des chaînes de caractères pour la partie "TEST DU PROGRAMME nomfichier".

== Kylian GACHET (1A)

=== Simplicité

==== Meilleur

|=========================================================================================================
| Num Algo | Lisibilité | Qualité | Maintenabilité | Note | Classement Final

| 2 | 9/10 | 10/10 | 7/10 | 26/30 +
=> `*≈17.3/20*` | #*1*#

| 3 |7/10 | 7/10 | 8/10 | 22/30 +
divisé par 2 car ne fonctionne pas => 11/30 +
=> ≈7.3/20  | 2

| 23 | 8/10 | 4/10 | 5/10 | 17/30 +
divisé par 2 car ne passe pas les tests => 8.5/30 +
=> ≈5.6/20  | 3

|=========================================================================================================

`Algorithme Simplicité - Meilleur N°2 :` +

[.text-justify]
* *Lisibilité :* 
** _Justification_ : Les noms de variables sont explicites et bien choisis, par exemple `motsParLettre` pour représenter la map associant chaque lettre à une liste de mots. Cela rend le code facile à comprendre et à suivre.
** _Exemple_ : Les noms de variables tels que `table_ordre`, `liste_t`, `ajouter_mot` sont des exemples de lisibilité du code.

* *Qualité :* 
** _Justification_ : Le programme utilise des structures de données appropriées pour résoudre le problème, telles que les listes chaînées et les tables de correspondance. De plus, les fonctions sont bien définies pour effectuer des opérations spécifiques.
** _Exemple_ : L'utilisation de structures de données comme `cell_t` et `liste_t` ainsi que des fonctions comme `ajouter_cellule` et `rang` démontrent la qualité du code.

* *Maintenabilité :* 
** _Justification_ : Le code est divisé en sections claires avec des commentaires pour expliquer chaque section et chaque fonction. De plus, les noms de variables et de fonctions sont choisis de manière à faciliter la maintenance et les modifications ultérieures.
** _Exemple_ : Les commentaires décrivant les différentes sections du code et l'utilisation de noms significatifs pour les variables et les fonctions contribuent à la maintenabilité du programme.

`Algorithme Simplicité - Meilleur N°3 :` +

[.text-justify]
* *Lisibilité :* 
** _Justification_ : Utilise des commentaires pour expliquer le fonctionnement.
** _Exemple_ : Le commentaire explique clairement que la fonction "solution" trie les mots d'une chaîne de caractères selon un ordre spécifié.

* *Qualité :* 
** _Justification_ : Approche originale qui évite les comparaisons entre les chaînes de caractères. De plus `Codacy` a detecté : Pas de package. Trop  de caractére sur une même ligne. +
Toutes les classes, interfaces, énumérations et annotations doivent appartenir à un package nommé
** _Exemple_ : Utilisation d'une table de correspondance pour déterminer l'ordre des mots, ce qui peut améliorer la qualité en évitant des opérations coûteuses de comparaison. +

* *Maintenabilité :* 
** _Justification_ : Utilisation de fonctions distinctes pour rendre le code modulaire.
** _Exemple_ : La fonction "diviserMots" extrait les mots d'une chaîne de caractères, ce qui facilite la maintenance et la réutilisation du code.

`Algorithme Simplicité - Meilleur N°23 :` +

[.text-justify]
* *Lisibilité :* 
** _Justification_ : Noms de variables explicites et bien choisis.
** _Exemple_ : La variable "motsParLettre" représente la map associant chaque lettre à une liste de mots.

* *Qualité :* 
** _Justification_ : Fonctionne mais ne passe pas les tests, cependant bonne gestion des mots. De plus `Codacy` a detecté qu'il avait parfois des caractére inutile.
** _Exemple_ : La méthode "trierMots" divise correctement la phrase en mots, trie les mots par ordre alphabétique et les concatène pour renvoyer la phrase triée.

* *Maintenabilité :* 
** _Justification_ : Manque de modularité et de réutilisabilité.
** _Exemple_ : La logique de tri des mots pourrait être extraite dans une méthode séparée pour faciliter la maintenance et la réutilisation.

==== Pire

|=========================================================================================================
| Num Algo | Lisibilité | Qualité | Maintenabilité | Note | Classement Final

| 28 | 7/10 | 6/10 | 7/10 | 20/30 +
divisé par 2 car ne passe pas les tests => 10/30 +
=> ≈6.6/20 | 2

| 37 | 1/10 | 4/10 | 4/10 | 9/30 +
divisé par 2 car ne passe pas les tests => 4.5/30 +
=> `*≈ 3/20*` | #*1*#

|=========================================================================================================

`Algorithme Simplicité - Pire N°28 :` +

[.text-justify]
* *Lisibilité :* 
** _Justification_ : Le programme utilise des noms de variables et de fonctions clairs et significatifs. La structure du code est également bien organisée.
** _Exemple_ : Les noms de variables tels que `phrase`, `ordre`, `mots` et `ordreIndex` sont des exemples de lisibilité du code.

* *Qualité :* 
** _Justification_ : Le programme utilise des structures de données appropriées pour résoudre le problème, comme les listes et les maps. De plus, il utilise la méthode `sort` avec un comparateur personnalisé pour trier les mots selon l'ordre spécifié.
** _Exemple_ : L'utilisation de `List<String>`, `Map<Character, Integer>` et `Comparator.comparingInt` pour trier les mots démontre une bonne qualité du code.

* *Maintenabilité :* 
** _Justification_ : Le code est bien structuré. Cependant une extraction de partie de code pour en faire une méthode distinct manque et n'est pas négligable.


`Algorithme Simplicité - Pire N°37 :` +

[.text-justify]
* *Lisibilité :* 
** _Justification_ : Le programme utilise des noms de variables et de fonctions clairs et significatifs. Cependant la structure du code est trés mal organisé.
** _Exemple_ : Les noms de variables tels que `texte`, `ordre` et `mots` sont des exemples de bonne lisibilité du code. Le code n'est pas bien formaté/indenter (tout le code sur une seul ligne)

* *Qualité :* 
** _Justification_ : Le programme utilise des structures de données appropriées pour résoudre le problème, comme les listes et les maps. De plus, la classe `ComparateurOrdreFixe` implémente l'interface `Comparator` pour personnaliser l'ordre de tri. De plus `Codacy` a detecté que : L'utilisation de la forme d'importation `.* doit être évitée - java.util.*`. Et que : `'import'` doit être séparé de la ligne précédente ainsi que chaque ligne doit être séparé par une ligne.
** _Exemple_ : L'utilisation de `List<String>`, `Map<Character, Integer>` et `Comparator<String>` ainsi que l'implémentation de la méthode `compare` dans `ComparateurOrdreFixe` démontrent la qualité du code.

* *Maintenabilité :* 
** _Justification_ : Le code est bien structuré avec des méthodes et des classes distinctes pour des responsabilités spécifiques. De plus, les commentaires sont absents dans ce programme, ce qui pourrait affecter la maintenabilité à long terme. De plus, la structure du code est trés mal organisé pouvant affecté la prise en charge du code par quelqu'un d'autre.
** _Exemple_ :  La séparation des fonctionnalités dans des méthodes distinctes, comme `solution` et `compare`, contribue à la maintenabilité du programme. Mais le code sur une seul ligne ne contribue pas a la maintenabilité de celui-ci.


=== Efficacité

==== Meilleur

|=========================================================================================================
| Num Algo | Efficacité | Qualité | Temps d'exécution | Note | Classement Final

| 22 | 7 | 8 | 8  |  23/30 +
=> `≈15.3/20` | #*1*#

| 57 | 3 | 7 | 7  | 17/30 +
divisé par 2 car ne passe pas les tests => 8.5/30 +
=> ≈5.6/20 | 2

|=========================================================================================================

`Algorithme Efficacité - Meilleur N°22 :` +

[.text-justify]
* *Efficacité :* 
** _Justification_ : L'efficacité du programme dépend principalement de l'implémentation de la méthode sortWords qui effectue le tri des mots. La complexité actuelle de l'algorithme de tri est #O(n^2)#, ce qui implqiue que c'est un algorithme dont le temps d'exécution augmente quadratiquement avec la taille de l'entrée n.
** _Exemple_ : Dans l'état actuel du code, l'algorithme de tri utilise une approche de comparaison caractère par caractère, ce qui peut entraîner des performances moins optimales pour de grandes listes de mots.

* *Qualité :* 
** _Justification_ : Le code est bien structuré et facile à lire. Les noms de variables sont appropriés et les commentaires sont présents pour expliquer le but des différentes parties du code. Cependant, il pourrait y avoir des améliorations possibles en termes de gestion des erreurs, de gestion des exceptions et de documentation plus détaillée pour faciliter la compréhension et la maintenance du code. De plus `Codacy` detecte plusieurs lignes avec trop de caratéres ce qui peut compliquer la lecture du code.
** _Exemple_ : La méthode `solution` pourrait bénéficier d'une meilleure gestion des erreurs, telle que la vérification des paramètres d'entrée pour éviter les valeurs nulles ou non valides. De plus, une documentation plus détaillée des méthodes, en utilisant des commentaires JavaDoc, permettrait de mieux comprendre leur fonctionnement et leur utilisation.

* *Temps d'exécution :* 
** _Justification_ : Les temps d’exécution analysés via le programme `TestTempsExecution.java` (en milli-secondes) semblent être inconstants et dépendent surtout du nombre et du placement des espaces contenus dans les chaînes de caractère données.

|===
|*Tailles des chaînes (avec espace)*|*Temps d'exécution*
|1 caractères|~0.6329 ms
|10 caractères|~0.0429 ms
|100 caractères|~0.1554 ms
|1000 caractères|~3.3582 ms
|===


`Algorithme Efficacité - Meilleur N°57 :` +

[.text-justify]
* *Efficacité :* 
** _Justification_ : 

*** Création de la HashMap (orderMap) : +
*Complexité* : `O(n)`, où n est la taille de la liste d'ordre. +
_Justification_ : La création de la HashMap se fait en parcourant la liste d'ordre une fois et en insérant chaque élément dans la HashMap.

*** Parcours du texte caractère par caractère : +
*Complexité :* `O(m)`, où m est la longueur du texte. +
Justification : Le code parcourt chaque caractère du texte une seule fois pour construire les mots.

*** Tri des mots (sortWords) : +
*Complexité :* `O(k * n^2)`, où n est le nombre de mots et k est la longueur moyenne des mots. +
Justification : Le tri des mots se fait en utilisant une méthode de comparaison caractère par caractère. Dans le pire des cas, cela nécessite une comparaison de chaque caractère de chaque paire de mots, ce qui conduit à une complexité quadratique. +
 +

En combinant ces parties, la complexité globale du programme est estimée à #O(m + n^2 * k)#, où m est la longueur du texte, n est le nombre de mots et k est la longueur moyenne des mots. Cette estimation est approximative et peut varier en fonction de la taille réelle du texte, du nombre de mots et de la longueur des mots. O(m + n^2 * k) a une complexité trés élevée, car elle dépend non seulement de n^2, mais aussi de m et k. Cela signifie que le temps d'exécution peut augmenter de façon significative en fonction de ces paramètres supplémentaires. Si m, n et k sont tous relativement grands, alors cette complexité peut être très inefficace. +
Donc C(n) = m + n^2 * k donc de maniére plus général #O(n^2)#.

* *Qualité :* 
** _Justification_ : Il est bien structuré et facile à lire grâce à une indentation correcte et à des noms de variables et de fonctions significatifs. De plus, il utilise des listes pour stocker les caractères et les chaînes de caractères, ce qui est une approche appropriée pour résoudre le problème. +
Cependant, l'absence de commentaires Javadoc peut rendre le code moins compréhensible pour les autres développeurs qui souhaitent l'utiliser ou le maintenir. Les commentaires Javadoc aident à documenter les classes, les méthodes, les paramètres et les valeurs de retour, ce qui facilite la compréhension du code et son utilisation correcte. +
`Codacy` n'a pas remarquer de quelconque proléme avec ce code.

* *Temps d'exécution :* 
** _Justification_ : Les temps d’exécution analysés via le programme `TestTempsExecution.java` (en milli-secondes) semblent être inconstants et dépendent surtout du nombre et du placement des espaces contenus dans les chaînes de caractère données. Cependant on remarque que le programme met beaucoup de temps pour 1 caractére mais beaucoup moins de temps que la moyenne pour 1000 caractéres.

|===
|*Tailles des chaînes (avec espace)*|*Temps d'exécution*
|1 caractères|~4.5043 ms
|10 caractères|~0.046 ms
|100 caractères|~0.1107 ms
|1000 caractères|~1.1139 ms
|===

==== Pire

|=========================================================================================================
| Num Algo | Efficacité | Qualité | Temps d'exécution | Note | Classement Final

| 7 | 9 | 7 |  9 | 25/30 +
divisé par 2 car ne passe pas les tests et ne réalise pas en aucun cas ce qui est demandé lors de cette SAE => 12.5/30 +
=> `≈8.3/20` | #*1*#

| 20 | 7 | 8 |  9 | 24/30 +
=> =16/20 | 2

|=========================================================================================================

`Algorithme Efficacité - Pire N°7 :` +

[.text-justify]
* *Efficacité :* 
** _Justification_ : Complexité #(O(n))#
** _Exemple_ : La complexité de ce code dépend principalement de la taille de la chaîne de caractères donnée. Lorsque la chaîne de caractères est parcourue pour effectuer les opérations nécessaires, la complexité est linéaire, c'est-à-dire O(n), où n est la taille de la chaîne de caractères. Cela signifie que le temps d'exécution augmente proportionnellement avec la taille de la chaîne.

* *Qualité :* 
** _Justification_ : Le code est structuré de manière claire et lisible. Les noms des variables et des méthodes sont descriptifs, ce qui facilite la compréhension du code. De plus, le code utilise des listes pour stocker les caractères et les chaînes de caractères, ce qui est une approche appropriée pour résoudre le problème.
** _Exemple_ : Les nom de variable tels que : `ordre` et `result` sont descriptives.

* *Temps d'exécution :* 
** _Justification_ : Les temps d’exécution analysés via le programme `TestTempsExecution.java` (en milli-secondes) semblent dépendre surtout du nombre et du placement des espaces contenus dans les chaînes de caractère données. Le temps d'éxecution est proportionnel a la taille de la liste.

|===
|*Tailles des chaînes (avec espace)*|*Temps d'exécution*
|1 caractères|~0.4259 ms
|10 caractères|~0.3793 ms
|100 caractères|~2.3706 ms
|1000 caractères|~12.1586 ms
|===

`Algorithme Efficacité - Pire N°20 :` +

[.text-justify]
* *Efficacité :* 
** _Justification_ : Le code utilise un tri à bulles pour trier les mots dans les listes. La complexité du tri à bulles est de O(n^2), où n est le nombre total de mots à trier. De plus, il y a une boucle imbriquée qui parcourt tous les mots et compare les caractères selon l'ordre spécifié. Cela ajoute une complexité supplémentaire de O(m), où m est la longueur maximale d'un mot. Par conséquent, la complexité globale du code est de O(n^2 * m), et de maniére général #O(n^2)#, ce qui peut être inefficace pour des entrées de grande taille.
** _Exemple_ : Le code utilise un tri à bulles pour trier les mots selon l'ordre spécifié. Cela implique une comparaison répétée des caractères des mots, ce qui peut entraîner des temps d'exécution plus longs pour des entrées avec de nombreux mots ou des mots de longueur importante.

* *Qualité :* 
** _Justification_ : Le code utilise des noms de variables et de méthodes descriptifs qui facilitent la compréhension du code. Par exemple, les variables `splited`, `result`, `tab`, `notfound` ont des noms qui indiquent leur rôle et leur contenu. De plus, les méthodes `solution` et `compare` ont des noms qui reflètent leur fonction dans le contexte du problème. Cependant `Codacy` a detecté : Trop  de caractére sur une même ligne.
** _Exemple_ : En utilisant des noms de variables et de méthodes descriptifs, il devient plus facile de comprendre le but et la logique du code. Par exemple, la variable `splited` indique qu'elle contient les mots découpés à partir de la chaîne de caractères donnée. De même, la méthode `compare` suggère qu'elle est utilisée pour comparer deux mots selon l'ordre spécifié. Cela améliore la lisibilité du code et facilite la maintenance à long terme.

* *Temps d'exécution :* 
** _Justification_ : Les temps d'exécution mesurés à l'aide du programme `TestTempsExecution.java` en millisecondes semblent varier et dépendent principalement du nombre et de l'emplacement des espaces présents dans les chaînes de caractères données.

|===
|*Tailles des chaînes (avec espace)*|*Temps d'exécution*
|1 caractères|~3.8645 ms
|10 caractères|~0.1122 ms
|100 caractères|~0.1556 ms
|1000 caractères|~1.8684 ms
|===

=== Sobriété

==== Meilleur

|=========================================================================================================
| Num Algo | Sobriété Numérique | Qualité | Consommation Electrique | Note | Classement Final

| 36 | 7 |  7 | 10 | 24/30 +
=> `=16/20` | #*1*#

| 58 | 7 | 7  | 8 | 22/30
 +
=> ≈14.6 | 2

|=========================================================================================================

`Algorithme Sobriété - Meilleur N°36 :` +

[.text-justify]
* *Sobriété Numérique :* 
** _Justification_ : L'algorithme a une complexité quadratique O(n^2) dans le pire des cas, ce qui signifie que le temps d'exécution augmente de manière quadratique par rapport à la taille de l'entrée. +
Cependant, cela indique tout de même une efficacité raisonnable et une consommation de ressources relativement stable, sans dépendance excessive à la taille de l'entrée.
{empty} +
** _Bonne pratique_ : L'utilisation de la méthode `sort` avec un comparateur personnalisé pour trier les mots selon l'ordre spécifié est une bonne pratique. Cela permet d'obtenir un résultat trié de manière efficace sans avoir à mettre en place un algorithme de tri personnalisé.
** _Point d'amélioration_ : Optimiser la manière dont les mots sont extraits de la chaîne de caractères. Actuellement, chaque caractère est vérifié individuellement pour déterminer s'il fait partie d'un mot. +
Cela pourrait être optimisé en utilisant des techniques telles que des expressions régulières ou des bibliothèques de traitement de texte pour une extraction plus rapide des mots. Cela pourrait potentiellement réduire le temps d'exécution pour les chaînes de caractères plus grandes ou complexes. 

* *Qualité :* 
** _Justification_ : L'algorithme utilise des structures de données appropriées, telles que des listes, pour stocker les mots et les caractères. Les noms des variables et des méthodes sont descriptifs, facilitant ainsi la compréhension du code. L'utilisation de la méthode sort avec un comparateur permet de trier efficacement les mots selon l'ordre spécifié. Cependant `Codacy` a detecté : Trop  de caractére sur une même ligne.
** _Exemple_ : Les variables sont nommées de manière significative, telles que `mots`, `motCourant`, `ordre`, ce qui aide à comprendre leur rôle dans l'algorithme. De plus, la méthode `solution` et la méthode `getOrderValue` sont clairement définies, compréhensible et leur objectif est compréhensible.

* *Consommation Electrique :* 

|===
|*Tailles des chaînes (avec espace)*|*Indice de consommation électrique (en Watt)*
|1 caractères|~3,49161
|10 caractères|~5,36096
|100 caractères|~4,52401
|1000 caractères|~3,79703
|===

`Algorithme Sobriété - Meilleur N°58 :` +

[.text-justify]
* *Sobriété Numérique :* 
** _Justification_ : L'algorithme a une complexité quadratique O(n^2) dans le pire des cas, ce qui signifie que le temps d'exécution augmente de manière quadratique par rapport à la taille de l'entrée. +
Cependant, cela indique tout de même une efficacité raisonnable et une consommation de ressources relativement stable, sans dépendance excessive à la taille de l'entrée.
{empty} +
** _Bonne pratique_ : L'utilisation d'une liste pour stocker les mots et d'une boucle linéaire pour les trier selon l'ordre spécifié est une approche simple et compréhensible. + 
De plus, l'utilisation de la classe StringBuilder pour la construction des mots est plus efficace que l'utilisation de concaténations de chaînes de caractères.
** _Point d'amélioration_ : L'algorithme pourrait être optimisé en utilisant une table de hachage (HashMap) pour associer chaque caractère à son indice dans l'ordre spécifié. + 
Cela éliminerait la recherche linéaire et permettrait d'obtenir l'indice directement en temps constant. En prétraitant l'ordre une seule fois, l'algorithme pourrait accéder rapidement à l'indice de chaque mot lors de la phase de tri.

* *Qualité :* 
** _Justification_ :  L'utilisation de la classe Comparator et de la méthode Collections.sort() pour trier les mots en fonction de l'ordre spécifié est une bonne pratique. Le code est également bien structuré et facile à comprendre. Cependant `Codacy` a detecté : Trop  de caractére sur une même ligne.

* *Consommation Electrique :* 

|===
|*Tailles des chaînes (avec espace)*|*Indice de consommation électrique (en Watt)*
|1 caractères|~3,52455
|10 caractères|~5,70018
|100 caractères|~5,18266
|1000 caractères|~4,24851
|===

==== Pire

|=========================================================================================================
| Num Algo | Sobriété Numérique | Qualité | Consommation Electrique | Note | Classement Final

| 5 |  |   |  | ?/20 | #*1*#

| 22 |  |   |  | ?/20 | 1

|=========================================================================================================

`Algorithme Sobriété - Pire N°5 :` +

[.text-justify]
* *Sobriété Numérique :* 
** _Justification_ : Le code utilise des structures de données appropriées pour stocker les mots, l'ordre des caractères et leur indice respectif dans l'ordre. Il n'y a pas d'utilisation excessive de ressources informatiques, tels que la mémoire ou le temps de calcul, qui pourrait être évitée. +
Le code effectue des opérations de manière efficace en utilisant des algorithmes adaptés.
{empty} +
** _Bonne pratique_ : Le code utilise des boucles et des structures de contrôle appropriées pour parcourir les caractères du texte et trier les mots, sans recourir à des opérations redondantes ou inutiles. +
Il utilise des structures de données existantes (comme `HashMap` et `ArrayList`) pour stocker les mots, l'ordre des caractères et les résultats intermédiaires.
** _Point d'amélioration_ : La méthode de tri utilisée (`bogoSort()`) est inefficace et peut avoir une complexité élevée, en particulier pour les textes de grande taille. Une amélioration serait de remplacer cette méthode par un algorithme de tri plus efficace et adapté aux besoins spécifiques de l'application. +
Le code pourrait bénéficier de commentaires supplémentaires pour expliquer les différentes parties du code, les intentions et les étapes clés de l'algorithme de tri. Cela améliorerait la lisibilité et la compréhension du code pour les développeurs travaillant sur ce projet.

* *Qualité :* 
** _Justification_ : Le programme divise la chaîne de caractères en mots en utilisant une expression régulière et les stocke dans une liste. Ensuite, il parcourt l'ordre spécifié et recherche les mots correspondants dans la liste, les ajoutant à une liste triée. +
Cependant, l'utilisation de boucles imbriquées peut entraîner une complexité temporelle plus élevée. De plus, l'utilisation de `sortedWords.contains()` à chaque itération pour vérifier si le mot est déjà présent peut également avoir un impact sur les performances. De plus, `Codacy` n'a détecté aucun probléme de qualité.

* *Consommation Electrique :* 
** _Justification_ : Au dela de 10 caractères le programme ne fonctionne pas.

|===
|*Tailles des chaînes (avec espace)*|*Indice de consommation électrique (en Watt)*
|1 caractères|~3,59873
|10 caractères|~5,29385
|100 caractères| X
|1000 caractères| X
|===

`Algorithme Sobriété - Pire N°22 :` +

[.text-justify]
* *Sobriété Numérique :* 
** _Justification_ : Le code est relativement simple et direct, ce qui facilite la compréhension et la maintenance.
Il utilise les structures de données appropriées pour stocker les mots, l'ordre des caractères et les mots triés. +
Il sépare les mots en utilisant une expression régulière et les ajoute à une liste.
{empty} +
** _Bonne pratique_ : Le code utilise des noms de variables clairs et compréhensibles pour améliorer la lisibilité. +
Les dépendances nécessaires sont correctement importées et utilisées.
** _Point d'amélioration_ : L'algorithme de tri peut être amélioré en utilisant des méthodes de tri plus efficaces, telles que le tri par fusion ou le tri rapide, qui offrent des performances meilleures que la boucle imbriquée actuelle. +
L'utilisation de `Arrays.asList()` peut être remplacée par une autre méthode pour éviter la création d'une liste immuable et permettre des modifications ultérieures si nécessaire. +
Il pourrait être utile d'ajouter une vérification supplémentaire pour exclure les mots vides ou les caractères spéciaux lors de l'ajout à la liste `sortedWords`.

* *Qualité :* 
** _Justification_ : Ce code implémente une méthode appelée solution qui trie une liste de mots en utilisant un ordre spécifié. Il utilise une approche de tri personnalisée en mélangeant aléatoirement les mots jusqu'à ce qu'ils soient triés. +
Le code utilise une structure de données appropriée pour stocker l'ordre des caractères et leur indice respectif. Il identifie également correctement les caractères alphabétiques et numériques dans le texte. Cependant, la méthode de tri utilisée peut entraîner des performances inefficaces dans certains cas.

* *Consommation Electrique :* 
** _Justification_ : Au dela de 10 caractères le programme ne fonctionne pas.

|===
|*Tailles des chaînes (avec espace)*|*Indice de consommation électrique (en Watt)*
|1 caractères|~4,36620
|10 caractères|~5,38312
|100 caractères| X
|1000 caractères| X
|===

== Illan Gabarra (1A)

=== Simplicité

=== Efficacité

=== Sobriété

Commen utilise les ressources, les stocke et les calcul qu'il fait (s'il passe en revue toutes la liste alors qu'il y pas besoins alors pas bon), complexité 